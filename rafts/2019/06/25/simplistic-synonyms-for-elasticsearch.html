<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="stylesheet" href="/assets/css/style.css?v=53cb3b26bd212352da6930353aac563e722f5226" media="screen" type="text/css">
  <link rel="stylesheet" href="/assets/css/print.css" media="print" type="text/css">

  <!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
  <![endif]-->

  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Simplistic Synonyms for Elasticsearch | blueprint</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Simplistic Synonyms for Elasticsearch" />
<meta name="author" content="David Daily" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="For this article, you should already have knowledge of Elasticsearch and of some relatively basic concepts like tokens, analyzers, and simple bool queries. If you need some background on these topics, or help setting up a local Elasticsearch instance, check out:" />
<meta property="og:description" content="For this article, you should already have knowledge of Elasticsearch and of some relatively basic concepts like tokens, analyzers, and simple bool queries. If you need some background on these topics, or help setting up a local Elasticsearch instance, check out:" />
<link rel="canonical" href="http://localhost:4000/2019/06/25/simplistic-synonyms-for-elasticsearch.html" />
<meta property="og:url" content="http://localhost:4000/2019/06/25/simplistic-synonyms-for-elasticsearch.html" />
<meta property="og:site_name" content="blueprint" />
<meta property="og:image" content="http://localhost:4000/assets/images/beverage-browsing-coffee-1157858.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-25T00:00:00+01:00" />
<script type="application/ld+json">
{"headline":"Simplistic Synonyms for Elasticsearch","dateModified":"2019-06-25T00:00:00+01:00","datePublished":"2019-06-25T00:00:00+01:00","url":"http://localhost:4000/2019/06/25/simplistic-synonyms-for-elasticsearch.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/06/25/simplistic-synonyms-for-elasticsearch.html"},"image":"http://localhost:4000/assets/images/beverage-browsing-coffee-1157858.jpg","author":{"@type":"Person","name":"David Daily"},"description":"For this article, you should already have knowledge of Elasticsearch and of some relatively basic concepts like tokens, analyzers, and simple bool queries. If you need some background on these topics, or help setting up a local Elasticsearch instance, check out:","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>
<header>
  <div class="inner">
    <a href="http://localhost:4000/">
      <h1>blueprint</h1>
    </a>
    <h2>BiggerPockets product & engineering blog</h2>
  </div>
</header>

<div id="content-wrapper">
  <div class="inner clearfix">
    <section id="main-content">
      
        <h1>Simplistic Synonyms for Elasticsearch</h1>
      

      <img src="/assets/images/beverage-browsing-coffee-1157858.jpg" />

      <p>For this article, you should already have knowledge of Elasticsearch and of some relatively basic concepts like <code class="highlighter-rouge">tokens</code>, <code class="highlighter-rouge">analyzers</code>, and simple <code class="highlighter-rouge">bool</code> queries. If you need some background on these topics, or help setting up a local Elasticsearch instance, check out:</p>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html</a></p>

<p>Now, onto the good part!</p>

<h2 id="the-problem">The Problem</h2>

<p>Here at BiggerPockets, we have all tons of different types of searchable records, most of which have some kind of location data associated with them. The issue that we have experienced is that users will search for records using state abbreviations such as <code class="highlighter-rouge">TX</code>, but records will be saved with the location of <code class="highlighter-rouge">Texas</code>, so the query will render no results. As you can imagine, this is a frustrating experience for end users.</p>

<h2 id="the-naive-solution">The Naive Solution</h2>

<p>There are multiple ways to solve this problem, one of them is to save full name of the state AND the state abbreviation in our index, perform a match query to on these two fields, and return the matching documents.</p>

<p>For example, if our mapping looked something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "states" : {
    "mappings" : {
      "properties" : {
        "state_abbrv" : {
          "type" : "keyword"
        },
        "state_name" : {
          "type" : "text"
        }
      }
    }
  }
}
</code></pre></div></div>

<p>and our index</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "took" : 16,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 3,
      "relation" : "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "states",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 1.0,
        "_source" : {
          "state_name" : "California",
          "state_abbrv" : "CA"
        }
      },
      {
        "_index" : "states",
        "_type" : "_doc",
        "_id" : "2",
        "_score" : 1.0,
        "_source" : {
          "state_name" : "New Mexico",
          "state_abbrv" : "NM"
        }
      },
      {
        "_index" : "states",
        "_type" : "_doc",
        "_id" : "3",
        "_score" : 1.0,
        "_source" : {
          "state_name" : "Colorado",
          "state_abbrv" : "CO"
        }
      }
    ]
  }
}
</code></pre></div></div>

<p>We could perform this query:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "query": {
    "bool": {
      "minimum_should_match": 1,
      "should": [
        {
          "match": {
            "state_name": "CA"
          }
        },
        {
          "match": {
            "state_abbrv": "CA"
          }
        }
      ]
    }
  }
}
</code></pre></div></div>

<p>or this query:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "query": {
    "bool": {
      "minimum_should_match": 1,
      "should": [
        {
          "match": {
            "state_name": "California"
          }
        },
        {
          "match": {
            "state_abbrv": "California"
          }
        }
      ]
    }
  }
}
</code></pre></div></div>

<p>and both give us the following results:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...

  "hits": [
      {
          "_index": "states",
          "_type": "_doc",
          "_id": "1",
          "_score": 1.0925692,
          "_source": {
              "state_name": "California",
              "state_abbrv": "CA"
          }
      }
  ]

...

</code></pre></div></div>

<p>Hooray! It worked! Ship it!</p>

<p>Well, I don’t know about you, but something about this just doesn’t sit too well with me. We are storing redundant data so every time that we store a record, we will be responsible for uploading that full state name and abbreviation into Elasticsearch. Plus, the query seems a little overly complex considering this type of search is probably something that we will need to do for numerous different searchable records.</p>

<p>Since this is not the solution that we will be going with, let’s blow our state index away and examine another solution.</p>

<p><code class="highlighter-rouge">$ curl -X DELETE localhost:9200/states</code></p>

<h2 id="a-better-way">A Better Way</h2>

<p>To demonstrate how synonyms work, let’s create a new index with only one state field that hold the full name of a state, and we will create a custom analyzer to analyze the field.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl -X PUT "localhost:9200/states" -H 'Content-Type: application/json' -d'
{
    "settings": {
        "index" : {
            "analysis" : {
                "filter" : {
                    "state_synonyms": {
                        "type" : "synonym",
                        "synonyms": ["ca, california", "nm, new mexico", "co, colorado"]
                    }
                },
                "analyzer" : {
                    "custom_state_analyzer" : {
                        "tokenizer" : "whitespace",
                        "filter" : ["lowercase", "state_synonyms"]
                    }
                }
            }
        }
    },
    "mappings": {
      "properties": {
        "state": { "type": "text", "analyzer": "custom_state_analyzer" }
      }
    }
}
'
</code></pre></div></div>

<p>This looks a lot more complicated than it is, but lets walk through what this is doing:</p>

<ul>
  <li>
    <p>We create a new token filter of type <code class="highlighter-rouge">synonym</code> called <code class="highlighter-rouge">state_synonyms</code>. What this filter does is, once our tokenizer has converted our input to a stream of tokens, adds synonym tokens into our token stream.</p>
  </li>
  <li>
    <p>We define a new custom analyzer called <code class="highlighter-rouge">custom_state_analyzer</code> that uses our custom <code class="highlighter-rouge">state_synonyms</code> filter. You will notice that our analyzer also utilizes the <code class="highlighter-rouge">lowercase</code> filter before our <code class="highlighter-rouge">state_synonyms</code> filter. This is just to downcase all of the tokens in our token stream to make our analyzer case insensitive.</p>
  </li>
</ul>

<p>We can use the <code class="highlighter-rouge">analyze</code> API to see what this analyzer is doing on our state field:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl -X GET localhost:9200/states/_analyze?pretty -H 'Content-Type: application/json' -d'{ "analyzer": "custom_state_analyzer", "text": "CA"}'
</code></pre></div></div>

<p>and get the response</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "tokens" : [
    {
      "token" : "ca",
      "start_offset" : 0,
      "end_offset" : 2,
      "type" : "word",
      "position" : 0
    },
    {
      "token" : "california",
      "start_offset" : 0,
      "end_offset" : 2,
      "type" : "SYNONYM",
      "position" : 0
    }
  ]
}
</code></pre></div></div>
<p>So even though we only search for <code class="highlighter-rouge">CA</code>, our analyzer is tokenizing our query, then inserting another token that is a synonym of <code class="highlighter-rouge">CA</code>, namely <code class="highlighter-rouge">California</code>. So now documents whose state field is <code class="highlighter-rouge">CA</code> or <code class="highlighter-rouge">California</code> will match our query. Cool!</p>

<p>To see this in action, lets populate our new index with a few documents:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl -XPUT 'localhost:9200/states/_doc/1?pretty' -H 'Content-Type: application/json' -d '{"state": "California"}'

$ curl -XPUT 'localhost:9200/states/_doc/2?pretty' -H 'Content-Type: application/json' -d '{"state": "New Mexico"}'

$ curl -XPUT 'localhost:9200/states/_doc/2?pretty' -H 'Content-Type: application/json' -d '{"state": "Colorado"}'
</code></pre></div></div>
<p>And issue a query to see what states match <code class="highlighter-rouge">CA</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl -XGET 'localhost:9200/states/_search?pretty' -H 'Content-Type: application/json' -d'
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "state": "CA"
        }
      }
    }
  }
}
'
</code></pre></div></div>
<p>And check out our response:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...

  "hits" : [
        {
          "_index" : "states",
          "_type" : "_doc",
          "_id" : "1",
          "_score" : 1.6068903,
          "_source" : {
            "state" : "California"
          }
        }
      ]
...
</code></pre></div></div>

<p>Nice!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Hopefully, this small example demonstrates some of the power that synonym filters have. You can use synonyms in phrase queries, multi term queries, and basically anything else that you can think of. Now go explore what you can do with these filters and even look into making other custom filters and analyzers of your own!</p>

<p>Happy searching!</p>



      
        <script src="https://utteranc.es/client.js"
                repo="biggerpockets/blueprint"
                issue-term="pathname"
                label="Comment"
                theme="github-light"
                crossorigin="anonymous"
                async>
        </script>
      
    </section>

    <aside id="sidebar">
      <h3>
        <a href="/" class="home">
          Blueprint Blog Home
        </a>
      </h3>

      <h3>
        <a href="https://www.biggerpockets.com/" class="home">
          BiggerPockets
        </a>
      </h3>

      <h3>
        <a href="https://www.biggerpockets.com/jobs" class="jobs">
          Jobs @ BiggerPockets
        </a>
      </h3>

      <!--<h3>Topics</h3>-->
      <!--<ul>-->
      <!--<li><a href="">PRODUCT</a></li>-->
      <!--<li><a href="">ENGINEERING</a></li>-->
      <!--<li><a href="">DESIGN</a></li>-->
      <!--<li><a href="">PRODUCT MANAGEMENT</a></li>-->
      <!--<li><a href="">UX</a></li>-->
      <!--<li><a href="">CULTURE</a></li>-->
      <!--<li><a href="">CAREER GROWTH</a></li>-->
      <!--</ul>-->
    </aside>
  </div>
</div>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-140809912-1', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>
